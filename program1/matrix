#!/bin/bash
trap "rm -f tmpfile$$ infile$$ infiletwo$$; echo 'SIGINT received: Deleting temp file then exiting!'; exit 1" INT
#exit codes
_EXITCODE=-1
#prints uasage
BADCMD=3 
BADARGCNT=5
BADINPUT=7
BADFILEINPUT=9

NUMARGS=$#
SUBCMD=$1
SUBCMDARGCNT=0
INFILE="infile$$"
INFILETWO="infiletwo$$"
_ROWCNT=0
_COLCNT=0
_RET=""

# checks that SUBCMD is one of the five implemented functions
usage() 
{
  if [ "$DEBUG" ]
  then
    echo -e "In usage()..."
    echo -e "\tSUBCMD is $SUBCMD"
  fi
  case $SUBCMD in 
    dims|transpose|mean|add|multiply) return 0;;
    *) _EXITCODE=$BADCMD && quit;;
  esac
}

# checks the number of arguments after a subcommand (dims, transpose, etc.) and cats stdin to a
# tmp file if possible
# in :expects that first and second args to function are the second and third args to the script
# out: INFILE is set to a valid file
chk_arg_count()
{
  if [ "$DEBUG" ]
  then
    echo -e "In chk_arg_count()..."
    echo "This is arg to func: $1"
  fi
  local subargs=$(expr $NUMARGS - 1)
	if [ "$DEBUG" ]
	then
		echo "subargs: $subargs"
	fi
	#if number of args is less than one, chk stdin
	if [[ ($subargs -lt 1) && ($SUBCMD = "dims" || $SUBCMD = 'mean' || $SUBCMD = 'transpose') ]]
	then
		if [ "$DEBUG" ]
		then
			echo "Checking for stdin"
		fi
		#read from stdin
		cat > "$INFILE"
		if [ ! -r "$INFILE" ]
		then
			_EXITCODE="$BADARGCNT"
			quit
		elif [ "$DEBUG" ]
		then
			echo "New file from stdin is readable."
		fi
		#if args == 1, then check for incorrect subcmd
	elif [[ ($subargs -eq 1) && ($SUBCMD = "dims" || $SUBCMD = 'mean' || $SUBCMD = 'transpose') ]]   
	then
		INFILE="$1"
	elif 	[[ ($subargs -eq 1) && ($SUBCMD = "add" || $SUBCMD = 'multiply') ]]   
	then
		_EXITCODE=$BADARGCNT
		quit
		#if args > 1, and subcmd takes only one arg, indicate that the second will be ignored
	elif [[ ( $subargs -gt 1 ) && ( $SUBCMD = 'dims' || $SUBCMD = 'mean' || $SUBCMD = 'transpose' ) ]]
	then
		_EXITCODE=$BADARGCNT
		quit
	elif [[ "$subargs" -gt 2 ]]
	then
		_EXITCODE=$BADARGCNT
		quit
	fi
	_RET=0   
}

# checks for valid file(s); assumed that this is called after chk_arg_count
# assumes that file arguments to script are passed in to function as $1 and $2
chk_input() 
{
  if [ "$DEBUG" ]
  then 
    echo -e "In chk_input()..."
  fi
  #if we're getting input from a single file...
  if [[ -f "$1" && -r "$1" && -s "$1" ]]
  then
    if [ "$DEBUG" ]
    then
      echo "First file readable"
    fi
    if [[ ($SUBCMD = 'dims' || $SUBCMD != 'add' || $SUBCMD != 'transpose') ]]
    then
      _RET=0
    #check if we should validate a second file argument 
    elif [[ $SUBCMD = 'add' || $SUBCMD = 'multiply' ]]
      then 
        if [[ -f "$2" && -r "$2" && -s "$2" ]]
        then
          if [ "$DEBUG" ] 
          then
            echo "Second file readable"
          fi
          INFILETWO="$2"
          _RET=0
        fi
    else 
      _EXITCODE="$BADFILEINPUT" 
      quit
    fi
  #then check if we're not getting input from stdin
  else 
    if [ "$DEBUG" ]
    then
      echo "Can't read file created from stdinput"
      echo INFILE: "$INFILE"
      cat "$INFILE"
    fi
    _EXITCODE="$BADFILEINPUT" 
    quit
  fi
}

quit() 
{
  if [ "$DEBUG" ]
  then
    echo -e "In quit()..."
    echo -e "\t _EXITCODE is $_EXITCODE"
  fi
  
  case $_EXITCODE in 
    "$BADCMD") echo -e "Usage: \tmatrix dims [MATRIX]\n\tmatrix transpose [MATRIX]"\
      "\n\tmatrix mean [MATRIX]\n\tmatrix add MATRIX1 MATRIX2"\
      "\n\tmatrix multiply MATRIX1 MATRIX2" >&2;;
    "$BADARGCNT") echo -e "Error: Number of arguments to subcommand invalid" >&2;;
    "$BADINPUT") echo -e "Error: File input not readable or too many inputs provided (stdin and"\
      "file)" >&2;;
    "$BADFILEINPUT") echo -e "Error: Wrong number of files or unable to read files supplied" >&2;;
		*);;
  esac
  #clean up tmp files
  rm -f "tmpfile$$" "infile$$" 
  exit $_EXITCODE
}

#counts the number of columns; expects a string
get_row_cnt()
{
  local count=0
  if [ "$DEBUG" ]
  then
    echo $1
  fi
  
  while read nop
  do
    ((count++))
  done < $1
  _RET=$count
  return 0
}

# expects two arguments, one the input file, and a second, numeric flag that is used for internal
# ...calls from other scripts that should not produce output
# out: if invoked with 1 as second arg, row\<space>col of matrix on stdin; if second arg is 0, sets $_ROWCNT and _COLCNT for use by calling function
dims() 
{
  local col_cnt
  local row_cnt

  #get column count
  read line1 < $1 
  col_cnt=$(echo $line1 | wc -w)

  #get row cnt
  row_cnt=$(wc -l < $1)
  
  if [ "$DEBUG" ] 
  then 
    echo -e "Column count: $col_cnt"
    echo -e "Row count: $row_cnt"
  fi
  
  _ROWCNT=$row_cnt 
  _COLCNT=$col_cnt 
  #if "internal" flag is set, we're being called by another func. and don't want to send to stdout 
  if [[ "$2" -eq 0 ]]
  then
    return 0
  else
    echo -e "$row_cnt $col_cnt"
	_EXITCODE=0    
	quit 
  fi
}

transpose() 
{
  dims "$1" 0
  local row_cnt=$_ROWCNT
  local col_cnt=$_COLCNT

  if [ "$DEBUG" ]
  then
    echo -e "In transpose..."
    echo -e "Row count: $row_cnt"
  fi
  #using arrays like we were advised _not_ to do
  #the following gets us a 1D array for each line of the file; each array is named rowarr<n>  
  i=0
  while IFS=$'\n' read -r line
  do
    IFS=$'\t'; read -ra rowarr$i < <(printf "%s" "$line")
		if [ $DEBUG ]
		then
			declare -p "rowarr$i"
		fi
		((i++))
  done < "$1"

  #for each column we create a string that will represent a row
  for (( c = 0; c < $row_cnt; c++ ))
  do
    var="rowarr$c[@]"
    #avoid printing a trailing tab
    g=`expr $row_cnt - 1`
    for (( z = 0; z < $col_cnt; z++ ))
    do
      nr="rowarr$c[$z]"
      if [ -z "newrow$z" ]
      then
        declare "newrow$z"=""
      fi
      if [ "$c" -eq "$g" ]
      then
        eval "newrow$z"+="${!nr}"
      else
        eval "newrow$z"+="${!nr}$'\t'"
      fi
      #echo $"newrow$z" #printf -v "newrow$c" "%s" "$e$'\t'"
      #declare -p "newrow$z"
      #"${!nr}"="$e"
      #printf -v "${!nr}" "%s" "foo"
      #printf -v "${!nr}" "%s" "$e\t"
      #${!nr} ="${!nr}\t$e"
    done
  done
  for (( p = 0; p < "$col_cnt"; p++ ))
  do
    out="newrow$p"
    echo "${!out}"
  done
	_EXITCODE=0
	quit
}

# takes a numerator and denominator, divides and rounds the quotient
mean_round()
{
	#follows the formula: (a + (b/2)*( (a>0)*2-1 )) / b
	num=$1
	den=$2
	if [ "$DEBUG" ]
	then
		echo "In mean_round..."
		echo "num: $num"
		echo "den: $den"
	fi
	#https://stackoverflow.com/questions/3953645/ternary-operator-in-bash
	sgn=$([ "$num" -gt 0 ] && echo 1 || echo 0)
	let quot="( ( num + ( den/2 ) * ( ( sgn*2 ) - 1 ) ) / den )"
	if [ "$DEBUG" ]
	then
		echo "sgn: $sgn"
		echo "quot: $quot"
	fi
	_RET="$quot"
}

mean() 
{
  dims "$1" 0
  local row_cnt=$_ROWCNT
  local col_cnt=$_COLCNT

  if [ "$DEBUG" ]
  then
    echo -e "In mean..."
    echo -e "Row count: $row_cnt"
  fi
  #the following gets us a 1D array for each line of the file; each array is named rowarr<n>  
  i=0
  while IFS=$'\n' read -r line
  do
    IFS=$'\t'; read -ra rowarr$i < <(printf "%s" "$line")
    ((i++))
  done < "$1"

  #for each column we create a sum that will be an element in our 1D output
  for (( c = 0; c < "$row_cnt"; c++ ))
  do
    var="rowarr$c[@]"
    #avoid printing a trailing tab
    g=`expr $row_cnt - 1`
    for (( z = 0; z < "$col_cnt"; z++ ))
    do
      nr="rowarr$c[$z]"
      #let's not overwrite our per-column val 
      if [ -z "sum$z" ]
      then
        declare -i "sum$z"=0
      fi
      let "sum$z"+=${!nr}
    done
  done
  outline=""
  for (( p = 0; p < "$col_cnt"; p++ ))
  do
		num="sum$p"
		mean_round ${!num} "$row_cnt"
    outline+="$_RET\t"
  done
  echo -e "$outline"
	_EXITCODE=0
	quit
}

#in 1: 'a' or 'm', to check whether the two matrices can be feasibly added or mulitplied
#in 2 and 3: the two matrices in question
#out: 0 or 1 in $_RET
feasible()
{
	_RET=1
  dims "$2" 0
	m1r="$_ROWCNT"
	m1c="$_COLCNT"
  
	dims "$3" 0
	m2r="$_ROWCNT"
	m2c="$_COLCNT"

	#can we add them?
	if [ "$1" == 'a' ]
	then
		if [[ $m1r -ne $m2r || $m1c -ne $m2c ]]
		then
			return 1
		fi
	elif [ "$1" == 'm' ]
	then
		if [[ "$m1c" -ne "$m2r" ]]
		then
			return 1
		fi
	else
		echo "Wrong argument, $1, to func feasible()" >&2
		return 1
	fi

	_RET=0
	return 0
}

add() 
{
	feasible 'a' "$1" "$2"
	if [ "$_RET" -eq 1 ]
  then
		if [ "$DEBUG" ]
		then
			echo "infeasible"
		fi
		_EXITCODE=$INCOMPATIBLE
		quit
  fi
  
  if [ "$DEBUG" ]
  then
		echo "In add() after feasible..."
	  echo "file1: $1"
	  echo "file2: $2"
	  echo "row_cnt: $_ROWCNT"
  fi

  #the following gets us a 1D array for each line of the file; each array is named rowarr<n>  
  i=0
  while IFS=$'\n' read -r line
  do
    IFS=$'\t'; read -ra mat1row$i < <(printf "%s" "$line")
    ((i++))
  done < "$1"

	#get a set of arrays for the second matrix
  j=0
  while IFS=$'\n' read -r line
  do
    IFS=$'\t'; read -ra mat2row$j < <(printf "%s" "$line")
    ((j++))
  done < "$2"

	#loop through the two sets of arrays and create a third
	for (( k = 0; k < "$_ROWCNT"; k++ ))  
	do
		for ((q = 0; q < "$_COLCNT"; q++ ))
		do
			local m1r="mat1row$k[$q]"
			local m2r="mat2row$k[$q]"
			#let's not overwrite our new row
			if [ ! -v "mat3row$k" ]
			then
				declare -a "mat3row$k"
				if [ "$DEBUG" ]
				then
					declare -p "mat3row$k"	
				fi
			fi
			m3r="mat3row$k[$q]"
			let "mat3row$k[$q]"=${!m1r}
			let "mat3row$k[$q]"+=${!m2r}
			
			if [ "$DEBUG" ]
			then
				echo "'mat1row$k[$q]': ${!m1r}"
				echo "'mat2row$k[$q]': ${!m2r}"
				echo "'mat3row$k[$q]': ${!m3r}"
			fi
		done
	done
	
	#print out the third array
	outline=""
  for (( r = 0; r < "$_ROWCNT"; r++ ))
  do
		for (( s = 0; s < "$_ROWCNT"; s++ ))
		do
			num="mat3row$r[$s]"			
			outline+="${!num}\t"
		done
		echo -e "$outline"
		outline=""
	done
	_EXITCODE=0
	quit
}

multiply() 
{
	feasible 'm' "$1" "$2"
	if [ "$_RET" -eq 1 ]
  then
		if [ "$DEBUG" ]
		then
			echo "infeasible"
		fi
		_EXITCODE=$INCOMPATIBLE
		quit
  fi
  
  if [ "$DEBUG" ]
  then
		echo "In add() after feasible..."
	  echo "file1: $1"
	  echo "file2: $2"
	  echo "row_cnt: $_ROWCNT"
  fi

  #the following gets us a 1D array for each line of the file; each array is named rowarr<n>  
  i=0
  while IFS=$'\n' read -r line
  do
    IFS=$'\t'; read -ra mat1row$i < <(printf "%s" "$line")
    ((i++))
  done < "$1"

	#get a set of arrays for the second matrix
  j=0
  while IFS=$'\n' read -r line
  do
    IFS=$'\t'; read -ra mat2row$j < <(printf "%s" "$line")
    ((j++))
  done < "$2"

	#loop through the two sets of arrays and create a third
	for (( k = 0; k < "$_ROWCNT"; k++ ))  
	do
		for ((q = 0; q < "$_COLCNT"; q++ ))
		do
			local m1r="mat1row$k[$q]"
			local m2r="mat2row$k[$q]"
			#let's not overwrite our new row
			if [ ! -v "mat3row$k" ]
			then
				declare -a "mat3row$k"
				if [ "$DEBUG" ]
				then
					declare -p "mat3row$k"	
				fi
			fi
			m3r="mat3row$k[$q]"
			let "mat3row$k[$q]"=${!m1r}
			let "mat3row$k[$q]"+=${!m2r}
			
			if [ "$DEBUG" ]
			then
				echo "'mat1row$k[$q]': ${!m1r}"
				echo "'mat2row$k[$q]': ${!m2r}"
				echo "'mat3row$k[$q]': ${!m3r}"
			fi
		done
	done
	
	#print out the third array
	outline=""
  for (( r = 0; r < "$_ROWCNT"; r++ ))
  do
		for (( s = 0; s < "$_ROWCNT"; s++ ))
		do
			num="mat3row$r[$s]"			
			outline+="${!num}\t"
		done
		echo -e "$outline"
		outline=""
	done
	_EXITCODE=0
	quit
}

usage 
if [ "$SUBCMD" = "dims" ]
then
  #dims only takes one argument
  chk_arg_count "$2"
  if [[ $_RET -eq 0 ]]
  then
    chk_input "$INFILE"
    if [[ $_RET -eq 0 ]]
    then
      dims "$INFILE" 1
    fi
  fi
fi

if [ "$SUBCMD" = "transpose" ]
then
  #transpose only takes one argument
  chk_arg_count "$2"
  if [[ $_RET -eq 0 ]]
  then
    chk_input "$INFILE"
    if [[ $_RET -eq 0 ]]
    then
      transpose "$INFILE"
    fi
  fi
fi

if [ "$SUBCMD" = "mean" ]
then
  #mean takes one argument
  chk_arg_count "$2"
  if [[ $_RET -eq 0 ]]
  then
    chk_input "$INFILE"
    if [[ $_RET -eq 0 ]]
    then
      mean "$INFILE"
    fi
  fi
fi

if [ "$SUBCMD" = "add" ]
then
  #add takes two arguments
  chk_arg_count "$2" "$3"
  if [[ "$_RET" -eq 0 ]] 
  then
    chk_input "$2"
    if [[ $_RET -eq 0 ]]
	then
		chk_input "$3"
		if [[ $_RET -eq 0 ]]
		then
			add "$2" "$3"
		fi
	fi
  fi
fi

if [ "$SUBCMD" = "multiply" ]
then
  #add takes two arguments
  chk_arg_count "$2" "$3"
  if [[ "$_RET" -eq 0 ]] 
  then
    chk_input "$2"
    if [[ $_RET -eq 0 ]]
	then
		chk_input "$3"
		if [[ $_RET -eq 0 ]]
		then
			multiply "$2" "$3"
		fi
	fi
  fi
fi


#cleanup files if any leftover
quit
