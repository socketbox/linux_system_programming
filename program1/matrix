#!/bin/bash
trap "rm -f tmpfile$$ infile$$ infiletwo$$; echo 'SIGINT received: Deleting temp file then exiting!'; exit 1" INT
#exit codes
_EXITCODE=-1
#prints uasage
BADCMD=3 
BADARGCNT=5
BADINPUT=7
BADFILEINPUT=9

NUMARGS=$#
SUBCMD=$1
SUBCMDARGCNT=0
INFILE="infile$$"
INFILETWO="infiletwo$$"
ROWCNT=0
COLCNT=0
_RET=""

# checks that SUBCMD is one of the five implemented functions
usage() 
{
  if [ "$DEBUG" ]
  then
    echo -e "In usage()..."
    echo -e "\tSUBCMD is $SUBCMD"
  fi
  case $SUBCMD in 
    dims|transpose|mean|add|multiply) return 0;;
    *) _EXITCODE=$BADCMD && quit;;
  esac
}

# checks the number of arguments after a subcommand (dims, transpose, etc.) and cats stdin to a
# tmp file if possible
# in :expects that first and second args to function are the second and third args to the script
# out: INFILE is set to a valid file
chk_arg_count()
{
  if [ "$DEBUG" ]
  then
    echo -e "In chk_arg_count()..."
    echo "This is arg to func: $1"
  fi
  local subargs=$(expr $NUMARGS - 1)
	if [ "$DEBUG" ]
	then
		echo "subargs: $subargs"
	fi
	#if number of args is less than one, chk stdin
	if [[ ($subargs -lt 1) && ($SUBCMD = "dims" || $SUBCMD = 'mean' || $SUBCMD = 'transpose') ]]
	then
		if [ "$DEBUG" ]
		then
			echo "Checking for stdin"
		fi
		#read from stdin
		cat > "$INFILE"
		if [ ! -r "$INFILE" ]
		then
			_EXITCODE="$BADARGCNT"
			quit
		elif [ "$DEBUG" ]
		then
			echo "New file from stdin is readable."
		fi
		#if args == 1, then check for incorrect subcmd
	elif [[ ($subargs -eq 1) && ($SUBCMD = "dims" || $SUBCMD = 'mean' || $SUBCMD = 'transpose') ]]   
	then
		INFILE="$1"
	elif 	[[ ($subargs -eq 1) && ($SUBCMD = "add" || $SUBCMD = 'multiply') ]]   
	then
		_EXITCODE=$BADARGCNT
		quit
		#if args > 1, and subcmd takes only one arg, indicate that the second will be ignored
	elif [[ ( $subargs -gt 1 ) && ( $SUBCMD = 'dims' || $SUBCMD = 'mean' || $SUBCMD = 'transpose' ) ]]
	then
		_EXITCODE=$BADARGCNT
		quit
	elif [[ "$subargs" -gt 2 ]]
	then
		_EXITCODE=$BADARGCNT
		quit
	fi
	_RET=0   
}

# checks for valid file(s); assumed that this is called after chk_arg_count
# assumes that file arguments to script are passed in to function as $1 and $2
chk_input() 
{
  if [ "$DEBUG" ]
  then 
    echo -e "In chk_input()..."
  fi
  #if we're getting input from a single file...
  if [[ -f "$1" && -r "$1" && -s "$1" ]]
  then
    if [ "$DEBUG" ]
    then
      echo "First file readable"
    fi
    if [[ ($SUBCMD = 'dims' || $SUBCMD != 'add' || $SUBCMD != 'transpose') ]]
    then
      _RET=0
    #check if we should validate a second file argument 
    elif [[ $SUBCMD = 'add' || $SUBCMD = 'multiply' ]]
      then 
        if [[ -f "$2" && -r "$2" && -s "$2" ]]
        then
          if [ "$DEBUG" ] 
          then
            echo "Second file readable"
          fi
          INFILETWO="$2"
          _RET=0
        fi
    else 
      _EXITCODE="$BADFILEINPUT" 
      quit
    fi
  #then check if we're not getting input from stdin
  else 
    if [ "$DEBUG" ]
    then
      echo "Can't read file created from stdinput"
      echo INFILE: "$INFILE"
      cat "$INFILE"
    fi
    _EXITCODE="$BADFILEINPUT" 
    quit
  fi
}

quit() 
{
  if [ "$DEBUG" ]
  then
    echo -e "In quit()..."
    echo -e "\t _EXITCODE is $_EXITCODE"
  fi
  
  case $_EXITCODE in 
    "$BADCMD") echo -e "Usage: \tmatrix dims [MATRIX]\n\tmatrix transpose [MATRIX]"\
      "\n\tmatrix mean [MATRIX]\n\tmatrix add MATRIX1 MATRIX2"\
      "\n\tmatrix multiply MATRIX1 MATRIX2" >&2;;
    "$BADARGCNT") echo -e "Error: Number of arguments to subcommand invalid" >&2;;
    "$BADINPUT") echo -e "Error: File input not readable or too many inputs provided (stdin and"\
      "file)" >&2;;
    "$BADFILEINPUT") echo -e "Error: Wrong number of files or unable to read files supplied" >&2;;
  esac
  #clean up tmp files
  rm -f "tmpfile$$" "infile$$" 
  exit $_EXITCODE
}

#counts the number of columns; expects a string
get_row_cnt()
{
  local count=0
  if [ "$DEBUG" ]
  then
    echo $1
  fi
  
  while read nop
  do
    ((count++))
  done < $1
  _RET=$count
  return 0
}

# expects two arguments, one the input file, and a second, numeric flag that is used for internal
# ...calls from other scripts that should not produce output
dims() 
{
  local col_cnt
  local row_cnt

  #get column count
  read line1 < $1 
  col_cnt=$(echo $line1 | wc -w)

  #get row cnt
  row_cnt=$(wc -l < $1)
  
  if [ "$DEBUG" ] 
  then 
    echo -e "Column count: $col_cnt"
    echo -e "Row count: $row_cnt"
  fi
  
  ROWCNT=$row_cnt 
  COLCNT=$col_cnt 
  if [[ "$2" -eq 0 ]]
  then
    return 0
  else
    echo -e "$row_cnt $col_cnt"
    exit 0
  fi
}

transpose() 
{
  dims "$1" 0
  local row_cnt=$ROWCNT
  local col_cnt=$COLCNT

  if [ "$DEBUG" ]
  then
    echo -e "In transpose..."
    echo -e "Row count: $row_cnt"
  fi
  #using arrays like we were advised _not_ to do
  #the following gets us a 1D array for each line of the file; each array is named rowarr<n>  
  i=0
  while IFS=$'\n' read -r line
  do
    readarray -t -d$'\t' rowarr$i < <(printf "%s" "$line")
    ((i++))
  done < "$1"

  #for each column we create a string that will represent a row
  for (( c = 0; c < $row_cnt; c++ ))
  do
    var="rowarr$c[@]"
    #avoid printing a trailing tab
    g=`expr $row_cnt - 1`
    for (( z = 0; z < $col_cnt; z++ ))
    do
      nr="rowarr$c[$z]"
      if [ -z "newrow$z" ]
      then
        declare "newrow$z"=""
      fi
      if [ "$c" -eq "$g" ]
      then
        eval "newrow$z"+="${!nr}"
      else
        eval "newrow$z"+="${!nr}$'\t'"
      fi
      #echo $"newrow$z" #printf -v "newrow$c" "%s" "$e$'\t'"
      #declare -p "newrow$z"
      #"${!nr}"="$e"
      #printf -v "${!nr}" "%s" "foo"
      #printf -v "${!nr}" "%s" "$e\t"
      #${!nr} ="${!nr}\t$e"
    done
  done
  for (( p = 0; p < "$col_cnt"; p++ ))
  do
    out="newrow$p"
    echo "${!out}"
  done
}

mean() 
{
  dims "$1" 0
  local row_cnt=$ROWCNT
  local col_cnt=$COLCNT

  if [ "$DEBUG" ]
  then
    echo -e "In mean..."
    echo -e "Row count: $row_cnt"
  fi
  #the following gets us a 1D array for each line of the file; each array is named rowarr<n>  
  i=0
  while IFS=$'\n' read -r line
  do
    readarray -t -d$'\t' rowarr$i < <(printf "%s" "$line")
    ((i++))
  done < "$1"

  #for each column we create a sum that will be an element in our 1D output
  for (( c = 0; c < $row_cnt; c++ ))
  do
    var="rowarr$c[@]"
    #avoid printing a trailing tab
    g=`expr $row_cnt - 1`
    for (( z = 0; z < "$col_cnt"; z++ ))
    do
      nr="rowarr$c[$z]"
      #let's not overwrite our per-column val 
      if [ -z "sum$z" ]
      then
        declare -i "sum$z"=0
      fi
      let "sum$z"+=${!nr}
    done
  done
  outline=""
  for (( p = 0; p < "$col_cnt"; p++ ))
  do
    out="sum$p"
    outline+="${!out}\t"
  done
  echo -e "$outline"
}

add() 
{
  local dims1=$(expr dims "$1")
  local dims2=$(expr dims "$2")
  if [[ $dims1 != $dims2 ]]
  then
    _EXITCODE=$INCOMPATIBLE
  fi
}

multiply() {
  local dims1=$(expr dims "$1")
  local dims2=$(expr dims "$2")
  cut  
  if [[ $dims1 != $dims2 ]]
  then
    echo nop
  fi
}

usage 
if [ "$SUBCMD" = "dims" ]
then
  #dims only takes one argument
  chk_arg_count "$2"
  if [[ $_RET -eq 0 ]]
  then
    chk_input "$INFILE"
    if [[ $_RET -eq 0 ]]
    then
      dims "$INFILE" 1
    fi
  fi
fi

if [ "$SUBCMD" = "transpose" ]
then
  #transpose only takes one argument
  chk_arg_count "$2"
  if [[ $_RET -eq 0 ]]
  then
    chk_input "$INFILE"
    if [[ $_RET -eq 0 ]]
    then
      transpose "$INFILE"
    fi
  fi
fi

if [ "$SUBCMD" = "mean" ]
then
  #mean takes one argument
  chk_arg_count "$2"
  if [[ $_RET -eq 0 ]]
  then
    chk_input "$INFILE"
    if [[ $_RET -eq 0 ]]
    then
      mean "$INFILE"
    fi
  fi
fi

if [ "$SUBCMD" = "add" ]
then
  #add takes two arguments
  if chk_arg_count
  then
    if chk_input;
    then
      if [[  $(chk_file_empty "$2") && $(chk_file_empty "$3") ]]
      then
        add "$2" "$3"
      fi
    fi
  fi
fi

#cleanup files if any leftover
rm -f tmpfile$$ infile$$ infiletwo$$
