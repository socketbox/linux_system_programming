#!/bin/bash
trap 'rm -f tmpfile$$ infile$$; echo "SIGINT received: Deleting temp file then exiting!"; exit 1' INT
#exit codes
_EXITCODE=-1
#prints uasage
BADCMD=3 
BADARGCNT=5
BADINPUT=7
BADFILEINPUT=9
INCOMPATIBLE=11

NUMARGS=$#
SUBCMD=$1
INFILE="infile$$"
_RET=""

# checks that SUBCMD is one of the five implemented functions
usage() 
{
  if [ "$DEBUG" ]
  then
    echo -e "In usage()..." >&2
    echo -e "\tSUBCMD is $SUBCMD" >&2
  fi
  case $SUBCMD in 
    dims|transpose|mean|add|multiply) return 0;;
    *) _EXITCODE=$BADCMD && quit;;
  esac
}

# checks the number of arguments after a subcommand (dims, transpose, etc.) and cats stdin to a
# tmp file if possible
# in :expects that first and second args to function are the second and third args to the script
# out: INFILE is set to a valid file
chk_arg_count()
{
  if [ "$DEBUG" ]
  then
    echo -e "In chk_arg_count()..." >&2
    echo "This is first arg to func: $1" >&2
    echo "This is second arg to func: $2" >&2
  fi
	local subargs=$((NUMARGS - 1))
	if [[ "$DEBUG" ]]
	then
		echo "subargs: $subargs" >&2
	fi
	#if number of args is less than one, chk stdin
	if [[ ($subargs -lt 1) && ($SUBCMD = "dims" || $SUBCMD = 'mean' || $SUBCMD = 'transpose') ]]
	then
		if [[ "$DEBUG" ]]
		then
			echo "Checking for stdin" >&2 
		fi
		#read from stdin
		cat > "$INFILE"
		if [[ ! -r "$INFILE" ]]
		then
			_EXITCODE="$BADARGCNT"
			quit
		elif [[ "$DEBUG" ]]
		then
			echo "New file from stdin is readable." >&2
		fi
		#if args == 1, then check for incorrect subcmd
	elif [[ ($subargs -eq 1) && ($SUBCMD = "dims" || $SUBCMD = 'mean' || $SUBCMD = 'transpose') ]]   
	then
		INFILE="$1"
	elif 	[[ ($subargs -eq 1) && ($SUBCMD = "add" || $SUBCMD = 'multiply') ]]   
	then
		_EXITCODE=$BADARGCNT
		quit
		#if args > 1, and subcmd takes only one arg, indicate that the second will be ignored
	elif [[ ( $subargs -gt 1 ) && ( $SUBCMD = 'dims' || $SUBCMD = 'mean' || $SUBCMD = 'transpose' ) ]]
	then
		_EXITCODE=$BADARGCNT
		quit
	elif [[ "$subargs" -gt 2 ]]
	then
		_EXITCODE=$BADARGCNT
		quit
	fi
	_RET=0   
}

# checks for valid file(s); assumed that this is called after chk_arg_count
# assumes that file arguments to script are passed in to function as $1 and $2
chk_input() 
{
  if [ "$DEBUG" ]
  then 
    echo -e "In chk_input()..." >&2
  fi
  #if we're getting input from a single file...
  if [[ -f "$1" && -r "$1" && -s "$1" ]]
  then
    if [ "$DEBUG" ]
    then
      echo "First file readable" >&2
      echo "subcmd: $SUBCMD" >&2
    fi
		if [[ ( "$SUBCMD" = 'dims' || "$SUBCMD" != 'add' || "$SUBCMD" != 'transpose' ) ]]
    then
      return 0
    #check if we should validate a second file argument 
    elif [[ "$SUBCMD" = 'add' || "$SUBCMD" = 'multiply' ]]
      then 
        if [[ -f "$2" && -r "$2" && -s "$2" ]]
        then
          if [ "$DEBUG" ] 
          then
            echo "Second file readable" >&2
          fi
          _RET=0
        fi
    else 
      _EXITCODE="$BADFILEINPUT" 
      quit
    fi
  #then check if we're not getting input from stdin
  else 
    if [ "$DEBUG" ]
    then
      echo "Can't read file created from stdinput" >&2
      echo INFILE: "$INFILE" >&2
      cat "$INFILE"
    fi
    _EXITCODE="$BADFILEINPUT" 
    quit
  fi
}

quit() 
{
  if [ "$DEBUG" ]
  then
    echo -e "In quit()..." >&2
    echo -e "\t _EXITCODE is $_EXITCODE" >&2
  fi
  
  case $_EXITCODE in 
    "$BADCMD") echo -e "Usage: \tmatrix dims [MATRIX]\n\tmatrix transpose [MATRIX]"\
      "\n\tmatrix mean [MATRIX]\n\tmatrix add MATRIX1 MATRIX2"\
      "\n\tmatrix multiply MATRIX1 MATRIX2" >&2;;
    "$BADARGCNT") echo -e "Error: Number of arguments to subcommand invalid" >&2;;
    "$BADINPUT") echo -e "Error: File input not readable or too many inputs provided (stdin and"\
      "file)" >&2;;
    "$BADFILEINPUT") echo -e "Error: Wrong number of files or unable to read files supplied" >&2;;
    "$INCOMPATIBLE") echo -e "Error: Matrices cannot be used in requested operation" >&2;;
		*);;
  esac
  #clean up tmp files
  rm -f "tmpfile$$" "infile$$" 
  exit $_EXITCODE
}

# expects two arguments, one the input file, and a second, numeric flag that is used for internal
# ...calls from other scripts that should not produce output
#out: row and col of the matrix provided, separated by a space
dims() 
{
  local col_cnt
  local row_cnt

  #get column count
  read line1 < "$1"
  col_cnt=$(echo "$line1"| wc -w)

  #get row cnt
  row_cnt=$(wc -l < "$1")
  
  if [ "$DEBUG" ] 
  then 
    echo -e "Column count: $col_cnt" >&2
    echo -e "Row count: $row_cnt" >&2
  fi
  
	echo -e "$row_cnt $col_cnt"
	return 0
}

transpose() 
{
	dimsout=$(dims "$1")
	row_cnt=$(echo "$dimsout" | cut -d' ' -f 1)
	col_cnt=$(echo "$dimsout" | cut -d' ' -f 2)

  if [ ! "$DEBUG" ]
  then
    echo -e "In transpose..." >&2
    echo -e "Row count: $row_cnt" >&2
  fi
  #using arrays like we were advised _not_ to do
  #the following gets us a 1D array for each line of the file; each array is named rowarr<n>  
  i=0
  while IFS=$'\n' read -r line
  do
    IFS=$'\t'; read -ra rowarr$i < <(printf "%s" "$line")
		if [ $DEBUG ]
		then
			declare -p "rowarr$i"
		fi
		((i++))
  done < "$1"

  #for each column we create a string that will represent a row
  for (( c = 0; c < $row_cnt; c++ ))
  do
    var="rowarr$c[@]"
    #avoid printing a trailing tab
    g=`expr $row_cnt - 1`
    for (( z = 0; z < $col_cnt; z++ ))
    do
      nr="rowarr$c[$z]"
      if [ -z "newrow$z" ]
      then
        declare "newrow$z"=""
      fi
      if [ "$c" -eq "$g" ]
      then
        eval "newrow$z"+="${!nr}"
      else
        eval "newrow$z"+="${!nr}$'\t'"
      fi
      #echo $"newrow$z" #printf -v "newrow$c" "%s" "$e$'\t'"
      #declare -p "newrow$z"
      #"${!nr}"="$e"
      #printf -v "${!nr}" "%s" "foo"
      #printf -v "${!nr}" "%s" "$e\t"
      #${!nr} ="${!nr}\t$e"
    done
  done
  for (( p = 0; p < "$col_cnt"; p++ ))
  do
    out="newrow$p"
    echo "${!out}"
  done
	_EXITCODE=0
	quit
}

# takes a numerator and denominator, divides and rounds the quotient
mean_round()
{
	#follows the formula: (a + (b/2)*( (a>0)*2-1 )) / b
	num=$1
	den=$2
	if [ "$DEBUG" ]
	then
		echo "In mean_round..." >&2
		echo "num: $num" >&2
		echo "den: $den" >&2
	fi
	#https://stackoverflow.com/questions/3953645/ternary-operator-in-bash
	sgn=$([ "$num" -gt 0 ] && echo 1 || echo 0)
	let quot="( ( num + ( den/2 ) * ( ( sgn*2 ) - 1 ) ) / den )"
	if [ "$DEBUG" ]
	then
		echo "sgn: $sgn" >&2
		echo "quot: $quot" >&2
	fi
	_RET="$quot"
}

mean() 
{
	dimsout=$(dims "$1")
	row_cnt=$(echo "$dimsout" | cut -d' ' -f 1)
	col_cnt=$(echo "$dimsout" | cut -d' ' -f 2)

  if [ "$DEBUG" ]
  then
    echo -e "In mean..." >&2
    echo -e "Row count: $row_cnt" >&2
  fi
  #the following gets us a 1D array for each line of the file; each array is named rowarr<n>  
  i=0
  while IFS=$'\n' read -r line
  do
    IFS=$'\t'; read -ra rowarr$i < <(printf "%s" "$line")
    ((i++))
  done < "$1"

  #for each column we create a sum that will be an element in our 1D output
  for (( c = 0; c < "$row_cnt"; c++ ))
  do
    var="rowarr$c[@]"
    #avoid printing a trailing tab
    g=`expr $row_cnt - 1`
    for (( z = 0; z < "$col_cnt"; z++ ))
    do
      nr="rowarr$c[$z]"
      #let's not overwrite our per-column val 
      if [ -z "sum$z" ]
      then
        declare -i "sum$z"=0
      fi
      let "sum$z"+=${!nr}
    done
  done
  outline=""
  for (( p = 0; p < "$col_cnt"; p++ ))
  do
		num="sum$p"
		mean_round ${!num} "$row_cnt"
    outline+="$_RET\t"
  done
  echo -e "$outline"
	_EXITCODE=0
	quit
}

#in 1: 'a' or 'm', to check whether the two matrices can be feasibly added or mulitplied
#in 2 and 3: the two matrices in question
#out: the dimensions of both matrices, "row1 col1 row2 col2", 101 if infeasible
feasible()
{
	m1dims=$( dims "$2" )
	m1r=$(cut -d' ' -f 1 < <(echo "$m1dims"))
	m1r=$(echo "$m1dims" | cut -d' ' -f 1)
	m1c=$(echo "$m1dims" | cut -d' ' -f 2)
  
	m2dims=$( dims "$3" )
	m2r=$(echo "$m2dims" | cut -d' ' -f 2)
	m2c=$(echo "$m2dims" | cut -d' ' -f 2)

	if [[ $DEBUG ]]
	then
		echo "In feasible()..." >&2
		echo "m1r: $m1r" >&2
		echo "m1c: $m1c" >&2
		echo "m2r: $m2r" >&2
		echo "m2c: $m2c" >&2
	fi

	#can we add them?
	if [[ "$1" == 'a' ]]
	then
		if [[ $m1r -ne $m2r || $m1c -ne $m2c ]]
		then
			return 101
		fi
	elif [[ "$1" == 'm' ]]
	then
		if [[ "$m1c" -ne "$m2r" ]]
		then
			return 101
		fi
	else
		echo "Wrong argument, $1, to func feasible()" >&2
		return 101
	fi
	echo "$m1r $m1c $m2r $m2c"
	return 0
}

add() 
{
	feasible 'a' "$1" "$2"
	if [ "$?" -eq 101 ]
  then
		if [ "$DEBUG" ]
		then
			echo "infeasible" >&2
		fi
		_EXITCODE=$INCOMPATIBLE
		quit
  fi
  
  if [ "$DEBUG" ]
  then
		echo "In add() after feasible..." >&2
	  echo "file1: $1" >&2
	  echo "file2: $2" >&2
	  echo "row_cnt: $_ROWCNT" >&2
  fi

  #the following gets us a 1D array for each line of the file; each array is named rowarr<n>  
  i=0
  while IFS=$'\n' read -r line
  do
    IFS=$'\t'; read -ra mat1row$i < <(printf "%s" "$line")
    ((i++))
  done < "$1"

	#get a set of arrays for the second matrix
  j=0
  while IFS=$'\n' read -r line
  do
    IFS=$'\t'; read -ra mat2row$j < <(printf "%s" "$line")
    ((j++))
  done < "$2"

	#loop through the two sets of arrays and create a third
	for (( k = 0; k < "$_ROWCNT"; k++ ))  
	do
		for ((q = 0; q < "$_COLCNT"; q++ ))
		do
			local m1r="mat1row$k[$q]"
			local m2r="mat2row$k[$q]"
			#let's not overwrite our new row
			if [ ! -v "mat3row$k" ]
			then
				declare -a "mat3row$k"
				if [ "$DEBUG" ]
				then
					declare -p "mat3row$k"	
				fi
			fi
			m3r="mat3row$k[$q]"
			let "mat3row$k[$q]"=${!m1r}
			let "mat3row$k[$q]"+=${!m2r}
			
			if [ "$DEBUG" ]
			then
				echo "'mat1row$k[$q]': ${!m1r}" >&2
				echo "'mat2row$k[$q]': ${!m2r}" >&2
				echo "'mat3row$k[$q]': ${!m3r}" >&2
			fi
		done
	done
	
	#print out the third array
	outline=""
  for (( r = 0; r < "$_ROWCNT"; r++ ))
  do
		for (( s = 0; s < "$_ROWCNT"; s++ ))
		do
			num="mat3row$r[$s]"			
			outline+="${!num}\t"
		done
		echo -e "$outline"
		outline=""
	done
	_EXITCODE=0
	quit
}

multiply() 
{
	mmdims=$(feasible 'm' "$1" "$2")
	if [ "$?" -eq 101 ]
  then
		if [ "$DEBUG" ]
		then
			echo "infeasible" >&2
		fi
		_EXITCODE=$INCOMPATIBLE
		quit
  fi
	IFS=' '; read -a dimarr < <(echo "$mmdims")
	#each index of the dimarr corresponds to a row or col dimesnion of a matrix	
	m1r=0
	m1c=1
	m2r=2
	m2c=3

	if [ "$DEBUG" ]
  then
		echo "In multiply() after feasible..." >&2
	  echo "file1: $1" >&2
	  echo "file2: $2" >&2
		readarray -t < <(echo "$dimarr") >&2
  fi

  #the following gets us a 1D array for each line of the file; each array is named rowarr<n>  
  i=0
  while IFS=$'\n' read -r line
  do
    IFS=$'\t'; read -ra mat1row$i < <(printf "%s" "$line")
    ((i++))
  done < "$1"

	#get a set of arrays for the second matrix
  j=0
  while IFS=$'\n' read -r line
  do
    IFS=$'\t'; read -ra mat2row$j < <(printf "%s" "$line")
    ((j++))
  done < "$2"

	m1rows="${dimarr[$m1r]}"
	m2rows="${dimarr[$m2r]}"
	m2cols="${dimarr[$m2c]}"
	#loop through the two sets of arrays and create a third
	declare m1r=0
	declare m2r=0
	for (( x = 0; x < m1rows; x++ ))  
	do
		dotsum=0	
		for (( y = 0; y < m2cols; y++ ))
		do
			for (( z = 0; z < m2rows; z++ ))
			do
				m1r="mat1row$x[$z]" 
				m2r="mat2row$z[$y]"
				if [ ! -v "sum$x$y" ]
				then
					declare sum$x$y=0
				fi
				sum="sum$x$y"
				
				if [[ "$DEBUG" ]]
				then
					echo "First sum: $sum$x$y" >&2
					echo "Second sum: ${!sum}" >&2
				fi	
				
				tmp1=$(( ${!m1r} * ${!m2r} ))
				let "sum$x$y"+=$(( $tmp1 ))
				
				if [[ "$DEBUG" ]]
				then
					echo "tmp1: $tmp1" >&2
				fi
			done
			printf "%s\t" "${!sum}" 
		done
		echo "" 
	done	
	#print out the third array
	outline=""
  for (( r = 0; r < 0; r++ ))
  do
		for (( s = 0; s < 0; s++ ))
		do
			num="mat3row$r[$s]"			
			outline+="${!num}\t"
		done
		echo -e "$outline"
		outline=""
	done
	_EXITCODE=0
	quit
}

#start by checking for proper command...
usage 
if [ "$SUBCMD" = "dims" ]
then
  #dims only takes one argument
  chk_arg_count "$2"
  if [[ $_RET -eq 0 ]]
  then
    chk_input "$INFILE"
    if [[ $_RET -eq 0 ]]
    then
      dims "$INFILE" 1
			quit
    fi
  fi
fi

if [ "$SUBCMD" = "transpose" ]
then
  #transpose only takes one argument
  chk_arg_count "$2"
  if [[ $_RET -eq 0 ]]
  then
    chk_input "$INFILE"
    if [[ $_RET -eq 0 ]]
    then
      transpose "$INFILE"
    fi
  fi
fi

if [ "$SUBCMD" = "mean" ]
then
  #mean takes one argument
  chk_arg_count "$2"
  if [[ $_RET -eq 0 ]]
  then
    chk_input "$INFILE"
    if [[ $_RET -eq 0 ]]
    then
      mean "$INFILE"
    fi
  fi
fi

if [ "$SUBCMD" = "add" ]
then
  #add takes two arguments
  chk_arg_count "$2" "$3"
  if [[ "$_RET" -eq 0 ]] 
  then
    chk_input "$2" "$3"
		if [[ "$?" -eq 0 ]] 
		then
			add "$2" "$3"
		fi
	fi
fi

if [ "$SUBCMD" = "multiply" ]
then
  #add takes two arguments
  chk_arg_count "$2" "$3"
  if [[ "$_RET" -eq 0 ]] 
  then
    chk_input "$2" "$3"
		if [[ $_RET -eq 0 ]]
		then
			multiply "$2" "$3"
		fi
	fi
fi

#cleanup files if any leftover
quit
